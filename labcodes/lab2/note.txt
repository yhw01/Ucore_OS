1.数据结构：
（1）物理页结构Page：kern/mm/memlayout.h
（2）管理所有连续内存空闲块的双向链表结构free_area_t：kern/mm/memlayout.h
（3）物理内存页管理框架pmm_manager：kern/mm/pmm.h
（4）双向链表结构list：libs/list.h
2.Exercise 1：
（1）文件：kern/mm/default_pmm.c
（2）ref：是否被引用
（3）flags：1(PG_reserved)->被保留，无法放入空闲链表中;0(PG_property)->可以放入空闲链表中
（4）property：记录连续内存空闲块的大小
（5）page_link：把多个连续内存空闲块链接在一起的双向链表指针
3.段页式管理：
（1）地址分为三种：逻辑地址（虚地址）、线性地址、物理地址
（2）逻辑地址--段式管理的地址映射-->线性地址--页式管理的地址映射-->物理地址
（3）在ucore系统中，段式管理仅起到一个过渡作用，将逻辑地址不加转换直接映射成线性地址
（4）页式管理将线性地址分为三部分：Directory、Table和Offset。在ucore系统中，页式管理通过一个二级的页表实现。
一级页表的起始物理地址存放在cr3寄存器中，这个地址必须是一个页对齐的地址，即低12位必须为0。
4.建立二级页表：
（1）整个页目录表和页表所占空间大小取决于二级页表要管理和映射的物理页数。
（2）大致流程：指向页目录表的指针已存储在boot_pgdir变量中->映射0~4MB的首个页表已经填充好->调用boot_map_segment函数进一步建立一一映射关系
具体处理过程以页为单位进行设置：linear_addr=phy_addr+0xC0000000
（3）页目录项内容=（页表起始物理地址&~0x0FFF）| PTE_U | PTE_W | PTE_P
（4）页表项内容=（pa&~0x0FFF）| PTE_P | PTE_W
     PTE_U：位3，表示用户态的软件可以读取对应地址的物理内存页内容
     PTE_W：位2，表示物理内存页内容可写
     PTE_P：位1，表示物理内存页存在
5.数据结构：
（1）PDX(la)：返回虚拟地址la的页目录项索引
（2）KADDR(pa)：获取pa的物理地址并返回相应的内核虚拟地址
（3）set_page_ref(page,1)：表示此页被引用一次
（4）page2pa(page)：获得page管理的那一页的物理内存地址
（5）struct Page* alloc_Page()：分配一页
（6）memset(void* s, char c, size_t n)：设置s指向内存区域的前面n个字节为字符c
（7）PTE_P 0x001：位1，表示物理内存页存在
（8）PTE_W 0x002：位2，表示物理内存页内容可写
（9）PTE_U 0x004：位3，表示用户态的软件可以读取对应地址的物理内存页内容
6.Exercise 2:
（1）pde_t：全称为page directory entry，一级页表的表项(pgdir表示一级页表本身)。
（2）pte_e：全称为page table entry，二级页表的表项
（3）二级页表不必要一开始就分配，而是在需要时再添加对应的二级页表
（4）查找二级页表(对应的二级页表不存在)->create参数为0，则get_pet返回NULL；如果create参数不为0，
则get_pte需要申请一个新的物理页，在一级页表中添加页目录项指向表示二级页表的新物理页（新申请的物理页全设置为0）。
7.页目录项：
   地址           页目录项组成部分                           ucore中的对应以及对ucore而言的潜在用处
  31:12    Page Table 4-KB aligned Address       这个页目录项对应的页表指向的物理页的物理地址，用于定位页表位置
  11:9                Avail                                     PTE_AVAIL，保留给OS使用
    8                Ignored                                            可忽略
    7             Page Size(0->4KB)                         PTE_PS,用于确定页的大小，0表示4KB
    6                   0                                      PTE_MBZ，恒为0，保留位信息
    5                Accessed                            PTE_A，用来表示页表是否被使用,用于替换算法
    4              Cache Disabled                            PTE_PCD，表示是否对页表进行缓存
    3              Write Through                        PTE_PWT，表示缓存是否使用write through写策略
    2              Use\Supervisor                            PTE_U，表示访问该页需要的特权级
    1               Read\Write                       PTE_W，表示页表是否允许读写。内存分配和释放时需要置位
    0                Present                  PTE_P，是存在位，如果为1表示存在，如果为0表示不存在，需要再分配一个物理页给页表
8.页表项
   地址            页表项组成部分                           ucore中的对应以及对ucore而言的潜在用处
  31:12         PAGE FRAME ADDRESS                      页表项指向的物理页的物理地址，用于定位页表位置
  11:9                Avail                                     PTE_AVAIL，保留给OS使用
   8:7                  0                                      PTE_MBZ，恒为0，保留位信息
    6                 Dirty                                 表示是否要在swap out的时候写回外存
    5                Accessed                                  PTE_A，用来表示页表是否被访问
   4:3                  0                                           恒为0，保留位信息
    2              Use\Supervisor                             PTE_U，表示访问该页需要的特权级
    1                Read\Write                        PTE_W，表示页表是否允许读写。内存分配和释放时需要置位
    0                 Present                PTE_P，是存在位，如果为1表示存在，如果为0表示不存在，需要再分配一个物理页给页表
9.ucore执行过程中出现页访问异常，硬件如何处理：
（1）将发生页访问异常的地址保存在cr2寄存器中
（2）设置错误代码，向栈中压入EFLAGS、CS、EIP和错误代码error code，如果发生在用户态，则之前还需要压入ss和esp，并切换到内核态
（3）引发Page Fault，根据中断描述符表查询到对应Page Fault的ISR，跳转到对应的ISR处执行，进行Page Fault处理，将外存的数据换到内存中
（4）进行上下文切换，返回中断之前的状态
10.处理函数：
（1）struct Page *page pte2page(*ptep)：获取ptep页表项对应的物理页
（2）free_page：释放一页
（3）page_ref_dec(page)：使得此页的引用数减一，并返回引用数，如果此页的引用数为0，那么应该被释放
（4）tlb_invalidate(pde_t *pgdir, uintptr_t la)：当修改的页表是那些正在使用的页表，那么无效
（5）PTE_P 0x001：位1，表示物理内存页存在
11.Exercise 3：
（1）读写物理地址前提：一级二级页表的项都设置了用户写权限->在一级页表先给用户写权限，再在二级页表上根据需要限制用户的权限，保护物理页
（2）一块内存在不同进程间共享->一个物理页被映射到不同的虚拟地址上->解除映射时，操作系统不能直接回收页，而是先检查物理地址是否映射到别的虚拟地址
12.Page的全局变量（数组）与页目录项和页表项的关系：
（1）每个页目录项记录了一个页表项的信息
（2）每个页表项记录了一个物理页的信息
（3）Page的全局变量中的每一项记录一个物理页的信息
（4）页目录项和页表项中保存的物理页面地址对应Page的全局变量的某一页
13.修改lab2实现虚拟地址和物理地址相等（取消映射）：
（1）在tools/kernel/ld将链接脚本的0xC0100000改为0x100000
（2）在kern/mm/memlayout.h将偏移量从0xC0000000改为0
（3）在kern/mm/pmm.c中关闭开启页表,boot_pgdir[0] = 0
14.伙伴分配：
（1）实质：一种特殊的“分离适配”，将内存按2的幂进行划分，
相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。
（2）优点：快速搜索合并（O(logN)时间复杂度）以及低外部碎片
（3）缺点；内部碎片，如遇到66单位需要分配128单位大小
（4）图示：          
    Size 16：                     16
                            /           \
    Size  8：              16              16
                       /       \       /        \
    Size  4：         8         8      8         8
                    /   \     /   \   /  \     /   \
    Size  2：      4     4   4     4  4   4   4     4
    
    Size  1：      ....     
    分配阶段：假设分配3，则需分配4->对16进行两次半分割->将3标记为已分配
             再次分配3->标记4
             再次分配6->标记2(因为1的3和4已经被分配)
    释放阶段：先释放3再释放4->释放4后，由于3、4相邻，所以合并生成1
              再释放2->1和2合并生成0，回到初始状态
15.Challenge 1：
（1）新建buddy_pmm.h及buddy_pmm.c文件用于实现pmm_manager规定的接口（函数指针）
（2）修改pmm.c的init_pmm_manager
 注意：make grade的时候需要修改(2)恢复到原来状态
 16.Slub:
 （1）slub把内存分组管理，每个组分别包含2^3、2^4...2^11个字节，另外包括96B和192B共11组。
 （2）slub相当于零售商，向伙伴系统批发内存，然后零售出去
 （3）包括仓库(kmem_cache_node)和营业厅(kmem_cache_cpu)两部分。营业厅只保留一个slab，
 当营业厅没有空闲内存时从仓库中换出其它的slab
 （4）slab是从伙伴系统批发的连续整页内存，零售商将整页的内存分成小内存
 （5）申请内存-->营业厅返回（内存不够）-->从仓库的partial变量中获取slab（没有了）-->利用伙伴算法获得
 （6）释放内存-->slab若为full状态，则修改为partial状态；若为partial状态，则不需要修改；若释放后全部空闲，则释放slab
